# Flutter Project Development Guide

## Project Overview

- **Project Name**: noexc
- **Framework**: Flutter
- **Language**: Dart
- **SDK Version**: ^3.7.2 (Compatible with Flutter 3.29.3)
- **Type**: Cross-platform mobile/desktop/web application with React Flow authoring tool
- **Status**: Fully functional accountability/habit-tracking chat application with comprehensive features, modular architecture, sequence-based conversation system, visual authoring tool, and advanced task management with deadline tracking
- **Current Development Focus**: Task deadline management, automatic status updates, enhanced session tracking, and AnimatedList synchronization fixes

### Recent Critical Bug Fixes (2025)

#### AnimatedList Synchronization Issues - RESOLVED
Two major UI bugs caused by AnimatedList state desynchronization have been fixed:

**1. Text Input Bug - First Message Disappearing**
- **Problem**: When users submitted text input, the first message in the chat would disappear
- **Root Cause**: `addUserResponseMessage()` in `MessageDisplayManager` added user messages to the data structure but failed to notify AnimatedList of the change
- **Solution**: Added `animatedListState.insertItem(0, duration: Duration.zero)` to maintain state synchronization
- **Location**: `lib/widgets/chat_screen/state_management/message_display_manager.dart`
- **Impact**: User messages now appear instantly without breaking the message flow

**2. Reset Button Bug - RangeError on Clear**
- **Problem**: Debug panel reset/clear buttons caused `RangeError (length): Invalid value: Only valid value is 0: 1` crashes
- **Root Cause**: `clearMessages()` method cleared the data structure but didn't remove items from AnimatedList state
- **Solution**: Added proper `removeItem()` loop to synchronize AnimatedList before clearing data
- **Location**: `lib/widgets/chat_screen/state_management/message_display_manager.dart`
- **Impact**: Debug panel controls now work reliably without crashes

**Key Learning**: AnimatedList requires explicit state management - every data structure change must have corresponding AnimatedList notification to prevent desynchronization.

#### Sequence Starting Logic Enhancement - IMPROVED
**Dynamic First Message ID System**
- **Enhancement**: Replaced hard-coded `ChatConfig.initialMessageId = 1` with dynamic first message detection
- **Benefit**: Sequence authors can now start sequences with any message ID, not just ID 1
- **Files Updated**: 
  - `FlowOrchestrator` - sequence transitions use dynamic starting
  - `RouteProcessor` - autoroute sequence switching uses first message ID
  - `ChatService` - initial message loading uses dynamic detection
  - `UserInteractionHandler` - choice-based sequence switching uses proper starting
- **New Method**: `SequenceManager.getFirstMessageId()` provides centralized logic for determining sequence start points
- **Impact**: More flexible sequence authoring and elimination of rigid ID 1 constraint

### UI Architecture Improvements
The chat system now has robust AnimatedList management ensuring:
- **Consistent State**: Data structure and UI state remain synchronized
- **Reliable Interactions**: Text input and reset operations work without side effects
- **Flexible Sequencing**: Sequences can start with any message ID structure
- **Debug Panel Stability**: All debug controls function reliably without crashes

## Architecture Overview

### Core Architecture
Flutter chat app with a **sequence-based conversation system**:
- **Dynamic message sequences** loaded from JSON files
- **User data storage** with template substitution (`{key|fallback}`)
- **Multi-text messages** with `|||` separator
- **Conditional routing** based on user attributes
- **Choice-based interactions** with data persistence
- **Semantic content system** for dynamic text variants

### Key Components

#### Core Services
- **ChatService** - Main orchestrator with focused processors (sequence_loader, message_processor, route_processor)
- **UserDataService** - Local storage using shared_preferences
- **SessionService** - Session tracking with daily reset functionality
- **LoggerService** - Centralized logging system (NEVER use print statements)
- **SemanticContentService** - Dynamic content resolution with graceful fallbacks

#### Models & Message Types
- **MessageType enum**: bot, user, choice, textInput, autoroute, dataAction
- **ChatMessage** - Core message model with multi-text support (`|||`)
- **Choice** - User interaction options with optional custom values
- **DataAction** - Data modification operations (set, increment, decrement, reset, trigger)

#### UI Architecture
- **ChatScreen** - Main container
- **ChatStateManager** - Split into service_manager, message_display_manager, user_interaction_handler
- **UserPanelOverlay** - Debug panel with scenario testing and variable editing

## Critical Rules

### Logging (MANDATORY)
- **NEVER use print() statements - ALWAYS use LoggerService**
- Import: `final logger = LoggerService();`
- Levels: `debug()`, `info()`, `warning()`, `error()`, `critical()`
- Component methods: `logger.route()`, `logger.semantic()`, `logger.ui()`

### Testing (TDD Required)
- **ALWAYS use Test-Driven Development** (Red-Green-Refactor cycle)
- Write tests BEFORE implementing functionality
- **290+ passing tests** across models, services, widgets, validation
- Test files mirror `lib/` directory structure in `test/`
- Never commit code without corresponding tests

#### Testing Best Practices - Low Output First (Context Efficiency)
**ALWAYS start with minimal output commands to save context and iterate faster:**

##### Phase 1: Ultra-Quiet Testing (Start Here)
```bash
# Quietest TDD mode - minimal output, fastest feedback
dart tool/tdd_runner.dart --quiet test/specific_test.dart

# Only show failures - no noise from passing tests
flutter test --reporter failures-only

# Compact one-line format - quick overview
flutter test --reporter compact

# Quick visual summary - instant status check
./tool/quick_test_summary.sh
```

##### Phase 2: Targeted Testing (When You Need More Info)
```bash
# Test specific patterns only
flutter test --name "specific test pattern" --reporter failures-only

# Single test file with minimal output
flutter test test/models/chat_message_test.dart --reporter compact

# Category-focused testing
flutter test test/services/ --reporter failures-only
flutter test test/models/ --reporter failures-only
```

##### Phase 3: Detailed Analysis (Only When Debugging)
```bash
# Expanded output for debugging specific failures
flutter test test/specific_test.dart --reporter expanded

# Full verbose mode (use sparingly - high context cost)
flutter test --verbose

# Comprehensive failure analysis
dart tool/test_analyzer.dart --quick
```

#### Test Helper Integration (Reduce Log Noise)
**ALWAYS use test helpers to minimize output during TDD:**
```dart
import '../test_helpers.dart';

setUp(() {
  setupQuietTesting(); // Minimal logging output
  // ... other test setup
});

// For error-handling tests (zero output)
setUp(() {
  setupSilentTesting(); // Completely silent
});

// Suppress expected errors in test blocks
test('should handle invalid input', () async {
  await withSuppressedErrorsAsync(() async {
    // Test code that triggers expected errors
    final result = await service.processInvalidData();
    expect(result, isA<ErrorResult>());
  });
});
```

#### Quick Test Aliases (Source for Efficiency)
```bash
# Load shortcuts: source tool/test_aliases.sh
tf          # failures only
tc          # compact format  
tq          # TDD quiet mode
ts          # quick summary
tf-services # service failures
tf-models   # model failures
ta-quick    # quick analysis
```

#### Parallel Testing Strategy (Advanced)
```bash
# Run multiple categories simultaneously
flutter test test/services/ --reporter compact &
flutter test test/models/ --reporter compact &
flutter test test/widgets/ --reporter compact &
wait
```

**Key Principle**: Start quiet, expand only when needed. This saves context tokens and accelerates TDD cycles.

## Development Guidelines

### Code Style and Linting
- Uses `package:flutter_lints/flutter.yaml` for recommended linting rules
- Follow Flutter/Dart naming conventions
- Use `super.key` for widget constructors
- Prefer `const` constructors where possible

### Testing (Test-Driven Development Required)
- **ALWAYS use Test-Driven Development (TDD)** for this project
- Write tests BEFORE implementing functionality (Red-Green-Refactor cycle)
- Follow TDD workflow:
  1. **Red**: Write a failing test that describes the desired behavior
  2. **Green**: Write the minimum code to make the test pass
  3. **Refactor**: Improve the code while keeping tests green
- **Comprehensive test coverage implemented**: 22 test files covering all major functionality
- Use `flutter test` to run tests
- Test files mirror the `lib/` directory structure in `test/`
- Import main app code using `package:noexc/main.dart`
- **Current test status: 293 tests passing, 7 failing** (Mostly due to sequence content changes)
- Failing tests are primarily outdated expectations from sequence updates, not functional issues
- Aim for high test coverage (minimum 80%) - Currently maintaining excellent coverage
- Never commit code without corresponding tests

### Documentation Maintenance
- **ALWAYS update this .agent.md file after significant changes**
- Update documentation when:
  - Adding new dependencies or packages
  - Changing project structure or architecture
  - Implementing new development patterns or practices
  - Adding new build scripts or development tools
  - Modifying testing strategies or requirements
  - Adding new platform support or configurations
  - Establishing new coding conventions or guidelines
- Keep the documentation current and accurate for new team members
- Document any project-specific patterns, utilities, or conventions
- Include examples and rationale for important decisions

### Current Application
The app is an **accountability and habit-tracking chat application** with a conversational AI companion named "Tristopher" (Trist) that helps users:

#### Core Functionality
- **Daily Task Management** - Set, track, and complete daily accountability tasks
- **Habit Tracking** - Monitor streaks, visit counts, and progress over time
- **Conversational AI Companion** - Interactive chat with personality-driven responses
- **Session Management** - Automatic tracking of visits, time of day, and user patterns
- **Onboarding Flow** - Welcome new users and collect essential information

#### Technical Features
- **Interactive chat interface** with bot and user messages
- **Sequence-based conversation system** with 7 modular chat flows (welcome, onboarding, task checking/setting, success/failure, sendoff)
- **Choice-based navigation** allowing users to select conversation paths
- **Cross-sequence navigation** enabling seamless flow between different conversation topics
- **Autoroute System** - conditional routing based on user attributes with invisible processing
- **Data Action System** - increment/decrement counters, set values, trigger events
- **Text input functionality** for user responses and personalization
- **Multi-text Messages** - separator-based message splitting (|||) for dramatic effect
- **Text Variants System** - dynamic message content with randomized alternatives
- **User Information Recall System** with local data persistence and session tracking
- **Text templating with fallback values** for personalized messaging
- **Message Queue System** - prevents race conditions and handles message delays
- **Error Handling** - comprehensive error management with custom exceptions
- **Asset Validation** - sequence and file integrity validation
- **Comprehensive Debug Panel** - sliding overlay with developer tools and controls
- **Chat State Management** - Reset, Clear, Reload controls for rapid development iteration
- **User Data Management** - Clear All Data functionality with confirmation for clean testing
- **Sequence Selection** - Integrated dropdown in debug panel for easy sequence switching
- **Modular component architecture** - divided ChatScreen widget
- **Centralized constants and configuration** for better maintainability
- **React Flow Authoring Tool** - visual editor for creating conversation sequences
- Chat sequences loaded from JSON asset files (`assets/sequences/`)
- Material Design theming with purple color scheme and dark/light mode support
- Advanced state management with ChangeNotifier pattern
- Clean chat message bubbles with sender differentiation
- Simulated typing delays between messages
- Loading indicator while chat sequences load
- Comprehensive test coverage following TDD principles (22 test files, all passing)

### Getting Started
1. Ensure Flutter SDK is installed and configured
2. Run `flutter pub get` to install dependencies
3. Use `flutter test` to verify tests (293 passing, 7 failing due to sequence content updates)
4. Use `flutter run` to start the accountability chat application
5. Explore the sequence-based chat interface with Tristopher (Trist)
6. Test the habit tracking by setting a daily task and checking completion
7. Navigate between different conversation sequences (welcome, onboarding, task management)
8. Access the Debug Panel by tapping the bug report icon in the AppBar for developer tools
9. Use chat state controls (Reset, Clear, Reload) for rapid development iteration
10. Test user data management with Clear All Data for clean testing scenarios
11. Switch sequences using the dropdown in the debug panel (10 available sequences)
12. **Test session management**: Notice visit counts and time-based greetings
13. **Test text variants**: Observe randomized message content on repeated interactions
14. **Test data actions**: Watch counters and flags update based on user choices
15. **Test task management**: Set deadlines, observe automatic status updates, test grace periods
16. **Test deadline tracking**: Use DateTimePickerWidget to set task deadlines and observe `isPastDeadline` computation
17. **Enhanced UX**: Notice questions displayed with choice buttons and text input fields
18. Begin development by following TDD principles and updating relevant models, services, or widgets
19. **Sequence system**: Add new conversation flows by creating JSON files in `assets/sequences/`
20. **Modular architecture**: Components are organized in `lib/widgets/chat_screen/` for easy maintenance
21. **Visual authoring**: Use React Flow tool in `noexc-authoring-tool/` for creating sequences
22. **Asset validation**: Run validation tools to ensure sequence integrity

### Notes
- This is a private package (`publish_to: 'none'`)
- Uses Material Design by default
- Hot reload is supported for faster development
- All platforms are pre-configured and ready for development
- Current Flutter version: 3.29.3 (stable channel)
- **Comprehensive test suite** - 30+ test files with 293 passing tests (7 failing due to sequence updates)
- **Architecture ready for scaling** - Modular design supports future growth
- **Cross-sequence navigation** - Seamless conversation flow management
- **Advanced task management** - Deadline tracking, automatic status updates, grace periods
- **Accountability focus** - App designed specifically for habit tracking and task completion
- **Visual authoring tool** - React Flow interface for non-technical sequence creation
- **Production ready** - Comprehensive error handling, validation, and testing
- **Recent focus**: Task deadline management, boolean computation, enhanced session tracking, and critical UI bug fixes