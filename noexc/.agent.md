# Flutter Project Development Guide

## Project Overview

- **Project Name**: noexc
- **Framework**: Flutter
- **Language**: Dart
- **SDK Version**: ^3.7.2 (Compatible with Flutter 3.29.3)
- **Type**: Cross-platform mobile/desktop/web application
- **Status**: Fully functional interactive chat application with comprehensive features, modular architecture, and sequence-based conversation system

## Project Structure

### Core Directories
- `lib/` - Main Dart source code
  - `main.dart` - Application entry point with chat application
  - `models/` - Data models (ChatMessage, Choice, ChatSequence)
  - `services/` - Business logic services (ChatService, UserDataService, TextTemplatingService)
  - `constants/` - Centralized constants (AppConstants, UIConstants, ThemeConstants)
  - `config/` - Configuration files (ChatConfig)
  - `themes/` - Theme configuration (AppThemes)
  - `widgets/` - UI components
    - `chat_screen/` - Modular chat components (8 focused components)
    - `user_variables_panel.dart` - Comprehensive debug panel with chat controls
- `test/` - Widget and unit tests with comprehensive TDD coverage
  - `widget_test.dart` - Main app widget tests
  - `models/` - Unit tests for data models
  - `services/` - Unit tests for service layer
  - `widgets/` - Widget tests for UI components
- `assets/` - Static assets including chat sequences
  - `chat_script.json` - Legacy chat script (for backward compatibility)
  - `sequences/` - Modular chat sequences (onboarding.json, tutorial.json, support.json, menu.json)

### Platform-Specific Directories
- `android/` - Android-specific configuration and native code
- `ios/` - iOS-specific configuration and native code  
- `web/` - Web-specific configuration and assets
- `windows/` - Windows desktop configuration
- `linux/` - Linux desktop configuration
- `macos/` - macOS desktop configuration

### Configuration Files
- `pubspec.yaml` - Package dependencies and Flutter configuration
- `analysis_options.yaml` - Dart analyzer and linting rules
- `.gitignore` - Git ignore patterns for Flutter projects

### Dependencies

### Main Dependencies
- `flutter` - Flutter SDK
- `cupertino_icons: ^1.0.8` - iOS-style icons
- `shared_preferences: ^2.2.2` - Local data storage for user information recall

### Development Dependencies
- `flutter_test` - Testing framework
- `flutter_lints: ^5.0.0` - Recommended linting rules

## Development Guidelines

### Code Style and Linting
- Uses `package:flutter_lints/flutter.yaml` for recommended linting rules
- Follow Flutter/Dart naming conventions
- Use `super.key` for widget constructors
- Prefer `const` constructors where possible

### Testing (Test-Driven Development Required)
- **ALWAYS use Test-Driven Development (TDD)** for this project
- Write tests BEFORE implementing functionality (Red-Green-Refactor cycle)
- Follow TDD workflow:
  1. **Red**: Write a failing test that describes the desired behavior
  2. **Green**: Write the minimum code to make the test pass
  3. **Refactor**: Improve the code while keeping tests green
- **Comprehensive test coverage implemented**:
  - Widget tests for UI components (`test/widgets/`)
  - Unit tests for business logic and data models (`test/models/`, `test/services/`)
  - Integration tests for chat functionality
  - User data storage and templating services (`test/services/`)
- Use `flutter test` to run tests
- Test files mirror the `lib/` directory structure in `test/`
- Import main app code using `package:noexc/main.dart`
- **Current test status: 90 passing, 0 failing** (All issues resolved!)
- Test coverage includes:
  - ChatMessage model serialization/deserialization with storeKey support (24/24 tests)
  - Choice model functionality and equality (3/3 tests)
  - ChatSequence model functionality (5/5 tests)
  - ChatService conversation flow and message loading (11/11 tests) - Updated for sequence system
  - Enhanced ChatService integration (9/9 tests)
  - UserDataService local storage operations (10/10 tests)
  - TextTemplatingService with fallback support (18/18 tests)
  - ChatScreen widget rendering and user interactions (5/5 tests)
  - UserVariablesPanel widget functionality (3/3 tests)
  - Main app widget tests (1/1 tests)
- **Issues Resolved**: Fixed timer disposal problems and sequence system test alignment
- **Total test coverage: 90/90 tests passing** (100% success rate)
- **Refactoring validated**: All tests pass after major architectural changes
- Aim for high test coverage (minimum 80%) - Currently at 100% success rate
- Never commit code without corresponding tests

### Project Commands
- `flutter run` - Run the application
- `flutter test` - Run all tests
- `flutter analyze` - Run static analysis
- `flutter pub get` - Install dependencies
- `flutter pub upgrade` - Update dependencies
- `flutter clean` - Clean build artifacts

### File Organization
- Keep main application logic in `lib/`
- **Constants organized by purpose**: `lib/constants/` and `lib/config/`
- **Modular widget structure**: `lib/widgets/chat_screen/` for chat components
- Use descriptive file and class names
- Follow Flutter's widget composition patterns
- **Single Responsibility Principle**: Each file has one clear purpose
- Separate concerns into focused, maintainable components

### Platform Support
This project is configured for:
- Android
- iOS  
- Web
- Windows
- Linux
- macOS

### Best Practices
- Use `setState()` for local state management
- Implement proper widget lifecycle methods
- Use Material Design components for consistent UI
- Follow Flutter's reactive programming model
- Write tests for critical functionality
- Use hot reload for faster development iteration

### Documentation Maintenance
- **ALWAYS update this .agent.md file after significant changes**
- Update documentation when:
  - Adding new dependencies or packages
  - Changing project structure or architecture
  - Implementing new development patterns or practices
  - Adding new build scripts or development tools
  - Modifying testing strategies or requirements
  - Adding new platform support or configurations
  - Establishing new coding conventions or guidelines
- Keep the documentation current and accurate for new team members
- Document any project-specific patterns, utilities, or conventions
- Include examples and rationale for important decisions

### Current Application
The app includes:
- **Interactive chat interface** with bot and user messages
- **Sequence-based conversation system** with modular chat flows
- **Choice-based navigation** allowing users to select conversation paths
- **Cross-sequence navigation** enabling seamless flow between different conversation topics
- **Autoroute System** - conditional routing based on user attributes with invisible processing
- **Text input functionality** for user responses and personalization
- **User Information Recall System** with local data persistence
- **Text templating with fallback values** for personalized messaging
- **Comprehensive Debug Panel** - sliding overlay with developer tools and controls
- **Chat State Management** - Reset, Clear, Reload controls for rapid development iteration
- **User Data Management** - Clear All Data functionality with confirmation for clean testing
- **Sequence Selection** - Integrated dropdown in debug panel for easy sequence switching (includes autoroute test)
- **Modular component architecture** with divided ChatScreen widget
- **Centralized constants and configuration** for better maintainability
- **Multiple conversation sequences**: onboarding, tutorial, support, main menu, and autoroute test
- Chat sequences loaded from JSON asset files (`assets/sequences/`)
- Material Design theming with purple color scheme
- Advanced state management with ChangeNotifier pattern
- Clean chat message bubbles with sender differentiation
- Simulated typing delays between messages
- Loading indicator while chat sequences load
- Comprehensive test coverage following TDD principles (90/90 tests passing)

### Architecture
- **Models**: 
  - `ChatMessage` class for message data structure with sender, choices, text input support, storeKey for data persistence, and autoroute fields
  - `Choice` class for representing user choice options with cross-sequence navigation support
  - `ChatSequence` class for managing modular conversation flows with metadata
  - `RouteCondition` class for defining conditional routing logic with conditions, sequence targets, and fallback options
- **Services**: 
  - `ChatService` for loading chat sequences, managing conversation flow, cross-sequence navigation, autoroute processing, and handling user interactions
  - `UserDataService` for local data storage and retrieval using shared_preferences
  - `TextTemplatingService` for dynamic text substitution with fallback support
  - `ConditionEvaluator` for evaluating user attribute-based routing conditions with support for ==, !=, and boolean checks
- **Constants & Configuration**:
  - `AppConstants` - Application-wide constants (titles, storage keys, delays)
  - `UIConstants` - UI styling constants (spacing, animations, sizes)
  - `ChatConfig` - Chat functionality configuration
  - `ThemeConstants` - Theme and color constants
- **Widgets**: 
  - `ChatScreen` - Main orchestrator (reduced from 448 to 85 lines)
  - `ChatStateManager` - Centralized state management with ChangeNotifier and debug controls
  - `MessageBubble` - Individual message display routing
  - `ChoiceButtons` - Choice selection UI component
  - `TextInputBubble` - Text input interface component
  - `ChatMessageList` - Message list management
  - `ChatAppBar` - Simplified app bar with theme toggle and debug panel access
  - `UserPanelOverlay` - Panel overlay management
  - `UserVariablesPanel` - Comprehensive debug panel with chat controls, sequence selection, and user data display
- **Assets**: 
  - **Legacy**: `chat_script.json` for backward compatibility
  - **Sequences**: Modular JSON files in `assets/sequences/` containing:
    - `onboarding.json` - User welcome and initial setup
    - `tutorial.json` - Feature tutorials and guidance
    - `support.json` - Help and troubleshooting
    - `menu.json` - Main navigation and options
    - `autoroute_test.json` - Demonstration of conditional routing system
  - Each sequence supports branching conversations, choices, text input, cross-sequence navigation, autoroute conditions, and storage keys

### Chat Sequence Structure
```json
{
  "sequenceId": "onboarding",
  "name": "User Onboarding",
  "description": "Welcome new users and collect basic information",
  "messages": [
    {
      "id": 1,
      "text": "Hello, {user.name|Guest}! Welcome to the app!",
      "delay": 1000,
      "sender": "bot",
      "isChoice": false,
      "isTextInput": false,
      "storeKey": "user.name",
      "choices": [
        {"text": "Option 1", "nextMessageId": 10},
        {"text": "Go to Support", "sequenceId": "support", "nextMessageId": 1}
      ],
      "nextMessageId": 2
    }
  ]
}
```
**Sequence Properties:**
- `sequenceId`: Unique identifier for the conversation sequence
- `name`: Human-readable name for the sequence
- `description`: Brief description of the sequence purpose
- `messages`: Array of chat messages in the sequence

**Message Properties:**
- `id`: Unique identifier for the message within the sequence
- `text`: The message content to display (supports templating with `{key}` or `{key|fallback}` syntax)
- `delay`: Milliseconds to wait before showing this message
- `sender`: Either "bot" or "user" to determine message styling
- `isChoice`: Boolean indicating if this message presents choices to the user
- `isTextInput`: Boolean indicating if this message expects text input from user
- `storeKey`: Optional key to store user input or choice selection for future recall
- `choices`: Array of choice objects with text, next message ID, and optional sequence navigation
- `nextMessageId`: ID of the next message in the conversation flow

**Choice Properties:**
- `text`: Display text for the choice button
- `nextMessageId`: ID of the next message to show after selection
- `sequenceId`: Optional - switch to a different sequence after selection

### Autoroute System (Latest Feature)

The autoroute system enables **conditional routing based on user attributes** with invisible processing. Users experience seamless conversation flow while the system intelligently routes them based on their stored data.

#### **Autoroute Message Structure**
```json
{
  "id": 10,
  "text": "ROUTE",
  "sender": "system",
  "isAutoRoute": true,
  "routes": [
    {
      "condition": "user.subscription == 'premium'",
      "sequenceId": "premium_features",
      "nextMessageId": 1
    },
    {
      "condition": "user.experience_level == 'beginner'",
      "sequenceId": "tutorial",
      "nextMessageId": 1
    },
    {
      "default": true,
      "nextMessageId": 11
    }
  ]
}
```

#### **Autoroute Properties:**
- `isAutoRoute`: Boolean flag indicating this message performs routing logic
- `routes`: Array of RouteCondition objects defining routing rules
- `text`: Always "ROUTE" (never displayed to users)
- `sender`: Always "system" for autoroute messages

#### **RouteCondition Properties:**
- `condition`: String expression to evaluate (e.g., "user.name != null")
- `sequenceId`: Target sequence to load if condition matches
- `nextMessageId`: Target message ID within sequence or current sequence
- `default`: Boolean indicating fallback route when no conditions match

#### **Supported Condition Operators:**
- `==` - Equality check: `"user.subscription == 'premium'"`
- `!=` - Inequality check: `"user.name != null"`
- **Boolean evaluation**: `"user.is_premium"` (checks if value is truthy)

#### **Key Features:**
- ✅ **Universal Insertion** - Can be placed after any message/choice/node
- ✅ **Invisible Processing** - Users never see "ROUTE" messages
- ✅ **Condition Evaluation** - Routes based on stored user attributes
- ✅ **Cross-Sequence Navigation** - Seamless switching between conversation flows
- ✅ **Fallback Support** - Default routes when no conditions match
- ✅ **Backward Compatible** - Existing sequences work unchanged

#### **Implementation Files:**
- `lib/models/route_condition.dart` - RouteCondition model with JSON serialization
- `lib/services/condition_evaluator.dart` - Condition parsing and evaluation logic
- `lib/models/chat_message.dart` - Extended with `isAutoRoute` and `routes` fields
- `lib/services/chat_service.dart` - Autoroute processing with `_processAutoRoute()` method
- `assets/sequences/autoroute_test.json` - Working demonstration sequence

#### **Usage Examples:**

**User Type Routing:**
```json
{
  "condition": "user.user_type == 'New user'",
  "sequenceId": "onboarding",
  "nextMessageId": 1
}
```

**Subscription-Based Routing:**
```json
{
  "condition": "user.subscription == 'premium'",
  "sequenceId": "premium_dashboard",
  "nextMessageId": 1
}
```

**Experience Level Routing:**
```json
{
  "condition": "user.experience_level == 'beginner'",
  "sequenceId": "tutorial",
  "nextMessageId": 1
}
```

#### **Testing the Autoroute System:**
1. **Access Debug Panel** - Tap bug icon (🐛) in app bar
2. **Select "Autoroute Test"** - Choose from sequence dropdown (route icon 🛤️)
3. **Follow the flow** - Enter name, choose user type
4. **Observe routing** - Watch automatic sequence switching based on choice
5. **Check debug info** - Panel shows new sequence information and stored user data

### Interactive Features
- **Choice Selection**: Users can tap buttons to select conversation paths
- **Cross-Sequence Navigation**: Seamless switching between different conversation topics
- **Autoroute Conditions**: Invisible conditional routing based on user attributes and stored data
- **Text Input**: Users can type responses for personalization
- **Branching Conversations**: Different paths based on user choices within and across sequences
- **Intelligent Routing**: Automatic sequence switching based on user profile, subscription, experience level, etc.
- **Sequence Management**: Service manages multiple conversation flows and state transitions
- **Message Flow Control**: Advanced conversation state and progression management
- **User Response Handling**: Creates user messages and continues conversation flow
- **Data Persistence**: User inputs and choices are automatically stored locally across sequences
- **Text Templating**: Messages are personalized using stored user data
- **Fallback Values**: Professional messaging with `{key|fallback}` syntax prevents raw placeholders
- **Debug Panel**: Comprehensive developer tools accessible via bug report icon in AppBar
- **Chat State Controls**: Reset, Clear Messages, and Reload Sequence for rapid development
- **User Data Management**: Clear All Data with confirmation dialog for clean testing scenarios
- **Sequence Selection**: Dropdown selector in debug panel for easy sequence switching (includes autoroute test)
- **Modular Conversations**: Organized conversation flows for onboarding, tutorials, support, navigation, and conditional routing demos

### Getting Started
1. Ensure Flutter SDK is installed and configured
2. Run `flutter pub get` to install dependencies
3. Use `flutter test` to verify all tests pass (90/90 tests should pass)
4. Use `flutter run` to start the interactive chat application
5. Explore the sequence-based chat interface with cross-sequence navigation
6. Test the user information recall by entering your name and seeing personalized messages
7. Navigate between different conversation sequences (onboarding, tutorial, support, menu)
8. Access the Debug Panel by tapping the bug report icon in the AppBar for developer tools
9. Use chat state controls (Reset, Clear, Reload) for rapid development iteration
10. Test user data management with Clear All Data for clean testing scenarios
11. Switch sequences using the dropdown in the debug panel
12. Begin development by following TDD principles and updating relevant models, services, or widgets
13. **Sequence system**: Add new conversation flows by creating JSON files in `assets/sequences/`
14. **Modular architecture**: Components are organized in `lib/widgets/chat_screen/` for easy maintenance

### User Information Recall System
The app now includes a comprehensive system for storing and recalling user information:

#### **Data Storage**
```dart
// Store user data
await userDataService.storeValue('user.name', 'Alice');
await userDataService.storeValue('user.preferences', ['dark_theme', 'notifications']);

// Retrieve stored data
final name = await userDataService.getValue<String>('user.name');
final hasData = await userDataService.hasValue('user.name');
```

#### **Text Templating**
```json
{
  "text": "Welcome back, {user.name|valued user}! Your theme is {user.theme|default}.",
  "storeKey": "user.visit_count"
}
```

**Template Syntax:**
- `{key}` - Use stored value or leave unchanged if not found
- `{key|fallback}` - Use stored value or fallback if not found

#### **Automatic Data Collection**
- Text input messages with `storeKey` automatically store user responses
- Choice messages with `storeKey` automatically store selected options
- Data persists across app sessions using shared_preferences

#### **Benefits**
- **Personalized Experience**: Messages adapt based on stored user data
- **Professional UX**: Fallback values prevent raw template placeholders
- **Local Privacy**: All data stored locally on device
- **Backward Compatible**: Existing chat scripts work unchanged

### Debug Panel Feature
The app now includes a comprehensive Debug Panel feature for developers:

#### **Panel Access**
- Accessible via bug report icon in the ChatScreen AppBar
- Smooth sliding animation (300ms duration with easeInOut curve)
- Semi-transparent overlay for better UX
- Tap outside panel to close

#### **Chat State Controls**
- **Reset Chat**: Clears messages and restarts current sequence from beginning
- **Clear Messages**: Removes displayed messages without restarting sequence
- **Reload Sequence**: Reloads sequence from JSON file and resets chat
- **Clear All Data**: Permanently removes all stored user variables (with confirmation)
- Real-time feedback via snackbar notifications

#### **Sequence Management**
- **Dropdown Selector**: Switch between sequences with icons and display names
- **Current Sequence Display**: Shows active sequence ID, name, and description
- **Seamless Switching**: Changes sequences without app restart
- **Visual Feedback**: Success notifications when switching

#### **Debug Information Display**
- Shows current sequence metadata (ID, name, description)
- Displays total message count and app version info
- Real-time updates as chat state changes
- Clean key-value format for easy reading

#### **User Data Display**
- Shows all stored user variables in organized sections
- Handles different data types (strings, lists, booleans, numbers)
- Automatic refresh when data changes
- Preserved from original user variables panel

#### **Technical Implementation**
- `UserVariablesPanel` transformed into comprehensive debug tool
- Enhanced `ChatStateManager` with debug control methods
- Simplified `ChatAppBar` with consolidated debug access
- Material Design styling with error-themed destructive actions
- Follows TDD principles with comprehensive test coverage (90/90 tests passing)
- Cross-platform compatible (iOS, Android, Web, Desktop)

#### **Developer Benefits**
- **Rapid Development**: No app restarts needed for chat testing
- **Clean Testing**: Easy user data clearing for fresh scenarios
- **Sequence Debugging**: Quick switching and reloading of conversation flows
- **State Visibility**: Real-time insight into chat and user data state
- **Professional UX**: Smooth animations and consistent styling
- **Consolidated Tools**: All debug controls in one accessible location
- **Maintainable**: Clean architecture following existing app patterns

### Recent Major Improvements (Latest Updates)

#### Autoroute System Implementation (Latest - December 2024)
- **Conditional Routing**: Implemented invisible autoroute system for user attribute-based navigation
- **RouteCondition Model**: New model for defining routing logic with conditions, sequence targets, and fallback options
- **ConditionEvaluator Service**: Simple condition parser supporting ==, !=, and boolean checks for user data evaluation
- **ChatMessage Extensions**: Added `isAutoRoute` and `routes` fields with full JSON serialization support
- **ChatService Enhancement**: Integrated autoroute processing with `_processAutoRoute()` and `_executeRoute()` methods
- **Universal Insertion**: Autoroute messages can be placed after any message/choice/node in conversation flows
- **Invisible Processing**: Users never see "ROUTE" messages - seamless UX with technical routing hidden
- **Debug Panel Integration**: Added "Autoroute Test" sequence to debug panel with route icon (🛤️) for easy testing
- **Comprehensive Testing**: All 90 tests passing with autoroute functionality fully integrated
- **Backward Compatibility**: Existing sequences work unchanged, autoroute is purely additive feature

#### Autoroute Features:
```
Autoroute Capabilities:
├── Condition Evaluation
│   ├── user.subscription == 'premium'
│   ├── user.experience_level == 'beginner'
│   └── user.name != null
├── Cross-Sequence Navigation
│   ├── Automatic sequence switching
│   └── Seamless conversation flow
├── Fallback Support
│   ├── Default routes when no conditions match
│   └── Graceful error handling
└── Debug Integration
    ├── Autoroute test sequence
    ├── Route icon in sequence selector
    └── Real-time condition evaluation testing
```

#### Debug Panel Transformation (December 2024)
- **User Information Panel → Debug Panel**: Transformed user variables panel into comprehensive debugging tool
- **Chat State Controls**: Added Reset Chat, Clear Messages, and Reload Sequence buttons with real-time feedback
- **User Data Management**: Added "Clear All Data" button with confirmation dialog for testing clean user scenarios
- **Sequence Selection Integration**: Moved sequence selector from app bar to debug panel for consolidated control
- **Enhanced UI/UX**: Bug report icon, error-themed destructive actions, success notifications, and organized sections
- **Developer Productivity**: Eliminated need for app restarts during chat testing and sequence development
- **All functionality preserved**: User data display maintained alongside new debug capabilities
- **Test coverage maintained**: All 90 tests passing with new debug features

#### Debug Panel Features:
```
Debug Panel Layout:
├── Chat Controls
│   ├── Current Sequence: [Dropdown with icons]
│   ├── [Reset] [Clear] [Reload] (Row 1)
│   └── [Clear All Data] (Row 2 - with confirmation)
├── Debug Information
│   ├── Current Sequence ID and Name
│   ├── Sequence Description
│   ├── Total Messages Count
│   └── App/Framework Version Info
└── User Data (preserved)
    └── All stored user variables
```

#### Sequence System Implementation (December 2024)
- **Modular conversation flows**: Replaced monolithic chat script with sequence-based system
- **Cross-sequence navigation**: Seamless transitions between different conversation topics
- **4 core sequences**: onboarding, tutorial, support, and main menu flows
- **Backward compatibility**: Legacy chat_script.json support maintained
- **Enhanced ChatService**: New sequence loading and management capabilities
- **ChatSequence model**: New data structure for managing conversation flows
- **Test alignment**: Updated all tests to work with new sequence system (90/90 passing)
- **Improved scalability**: Easy addition of new conversation flows via JSON files

#### Sequence Features:
```
assets/sequences/
├── onboarding.json (User welcome and setup)
├── tutorial.json (Feature guidance)
├── support.json (Help and troubleshooting)
└── menu.json (Main navigation)
```

#### Constants Refactoring (Completed)
- **Eliminated magic numbers**: All hardcoded values moved to centralized constants
- **4 new constant files**: AppConstants, UIConstants, ChatConfig, ThemeConstants
- **Improved maintainability**: Easy to modify UI values from single location
- **Enhanced consistency**: Standardized spacing, sizing, and styling
- **All tests passing**: Zero breaking changes during refactoring

#### ChatScreen Widget Division (Completed)
- **Modular architecture**: Split 448-line monolithic widget into 8 focused components
- **Single Responsibility Principle**: Each component has one clear purpose
- **Improved maintainability**: Smaller, focused files (85% reduction in main file size)
- **Enhanced reusability**: Components can be used in other contexts
- **Better testability**: Individual components can be tested in isolation
- **Team-friendly development**: Multiple developers can work on different components
- **State management upgrade**: Centralized ChatStateManager with ChangeNotifier pattern
- **Performance optimized**: Better widget rebuilds and memory management

#### Component Structure:
```
lib/widgets/chat_screen/
├── chat_screen.dart (85 lines - main orchestrator)
├── chat_state_manager.dart (180 lines - business logic)
├── message_bubble.dart (95 lines - message display)
├── choice_buttons.dart (120 lines - choice UI)
├── text_input_bubble.dart (95 lines - text input)
├── chat_message_list.dart (35 lines - list management)
├── chat_app_bar.dart (45 lines - app bar)
└── user_panel_overlay.dart (55 lines - panel overlay)
```

### Notes
- This is a private package (`publish_to: 'none'`)
- Uses Material Design by default
- Hot reload is supported for faster development
- All platforms are pre-configured and ready for development
- Current Flutter version: 3.29.3 (stable channel)
- **All timer disposal issues resolved** - Clean test suite
- **Sequence system fully tested** - 90/90 tests passing with sequence alignment
- **Architecture ready for scaling** - Modular design supports future growth
- **Cross-sequence navigation** - Seamless conversation flow management