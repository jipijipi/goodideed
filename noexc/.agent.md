# Flutter Project Development Guide

## Project Overview

- **Project Name**: noexc
- **Framework**: Flutter
- **Language**: Dart
- **SDK Version**: ^3.7.2
- **Type**: Cross-platform mobile/desktop/web application
- **Status**: New project (starter template)

## Project Structure

### Core Directories
- `lib/` - Main Dart source code
  - `main.dart` - Application entry point with chat application
  - `models/` - Data models (ChatMessage, Choice)
  - `services/` - Business logic services (ChatService, UserDataService, TextTemplatingService)
  - `widgets/` - UI components (ChatScreen, UserVariablesPanel)
- `test/` - Widget and unit tests with comprehensive TDD coverage
  - `widget_test.dart` - Main app widget tests
  - `models/` - Unit tests for data models
  - `services/` - Unit tests for service layer
  - `widgets/` - Widget tests for UI components
- `assets/` - Static assets including chat script JSON

### Platform-Specific Directories
- `android/` - Android-specific configuration and native code
- `ios/` - iOS-specific configuration and native code  
- `web/` - Web-specific configuration and assets
- `windows/` - Windows desktop configuration
- `linux/` - Linux desktop configuration
- `macos/` - macOS desktop configuration

### Configuration Files
- `pubspec.yaml` - Package dependencies and Flutter configuration
- `analysis_options.yaml` - Dart analyzer and linting rules
- `.gitignore` - Git ignore patterns for Flutter projects

### Dependencies

### Main Dependencies
- `flutter` - Flutter SDK
- `cupertino_icons: ^1.0.8` - iOS-style icons
- `shared_preferences: ^2.2.2` - Local data storage for user information recall

### Development Dependencies
- `flutter_test` - Testing framework
- `flutter_lints: ^5.0.0` - Recommended linting rules

## Development Guidelines

### Code Style and Linting
- Uses `package:flutter_lints/flutter.yaml` for recommended linting rules
- Follow Flutter/Dart naming conventions
- Use `super.key` for widget constructors
- Prefer `const` constructors where possible

### Testing (Test-Driven Development Required)
- **ALWAYS use Test-Driven Development (TDD)** for this project
- Write tests BEFORE implementing functionality (Red-Green-Refactor cycle)
- Follow TDD workflow:
  1. **Red**: Write a failing test that describes the desired behavior
  2. **Green**: Write the minimum code to make the test pass
  3. **Refactor**: Improve the code while keeping tests green
- **Comprehensive test coverage implemented**:
  - Widget tests for UI components (`test/widgets/`)
  - Unit tests for business logic and data models (`test/models/`, `test/services/`)
  - Integration tests for chat functionality
  - User data storage and templating services (`test/services/`)
- Use `flutter test` to run tests
- Test files mirror the `lib/` directory structure in `test/`
- Import main app code using `package:noexc/main.dart`
- Current test coverage includes:
  - ChatMessage model serialization/deserialization with storeKey support
  - Choice model functionality and equality
  - ChatService conversation flow and message loading
  - ChatScreen widget rendering and user interactions
  - UserDataService local storage operations (10/10 tests)
  - TextTemplatingService with fallback support (18/18 tests)
  - Enhanced ChatService integration (9/9 tests)
  - UserVariablesPanel widget functionality (3/3 tests)
- **Total test coverage: 77/77 tests passing** (excluding widget timing issues)
- Aim for high test coverage (minimum 80%)
- Never commit code without corresponding tests

### Project Commands
- `flutter run` - Run the application
- `flutter test` - Run all tests
- `flutter analyze` - Run static analysis
- `flutter pub get` - Install dependencies
- `flutter pub upgrade` - Update dependencies
- `flutter clean` - Clean build artifacts

### File Organization
- Keep main application logic in `lib/`
- Use descriptive file and class names
- Follow Flutter's widget composition patterns
- Separate concerns into different files as the project grows

### Platform Support
This project is configured for:
- ✅ Android
- ✅ iOS  
- ✅ Web
- ✅ Windows
- ✅ Linux
- ✅ macOS

### Best Practices
- Use `setState()` for local state management
- Implement proper widget lifecycle methods
- Use Material Design components for consistent UI
- Follow Flutter's reactive programming model
- Write tests for critical functionality
- Use hot reload for faster development iteration

### Documentation Maintenance
- **ALWAYS update this .agent.md file after significant changes**
- Update documentation when:
  - Adding new dependencies or packages
  - Changing project structure or architecture
  - Implementing new development patterns or practices
  - Adding new build scripts or development tools
  - Modifying testing strategies or requirements
  - Adding new platform support or configurations
  - Establishing new coding conventions or guidelines
- Keep the documentation current and accurate for new team members
- Document any project-specific patterns, utilities, or conventions
- Include examples and rationale for important decisions

### Current Application
The app includes:
- **Interactive chat interface** with bot and user messages
- **Choice-based navigation** allowing users to select conversation paths
- **Text input functionality** for user responses and personalization
- **User Information Recall System** with local data persistence
- **Text templating with fallback values** for personalized messaging
- **User Variables Panel** - sliding overlay displaying all stored user data
- Chat script loaded from JSON asset file (`assets/chat_script.json`)
- Material Design theming with purple color scheme
- Proper state management with StatefulWidget
- Clean chat message bubbles with sender differentiation
- Simulated typing delays between messages
- Loading indicator while chat script loads
- Comprehensive test coverage following TDD principles

### Architecture
- **Models**: 
  - `ChatMessage` class for message data structure with sender, choices, text input support, and storeKey for data persistence
  - `Choice` class for representing user choice options
- **Services**: 
  - `ChatService` for loading chat script, managing conversation flow, and handling user interactions
  - `UserDataService` for local data storage and retrieval using shared_preferences
  - `TextTemplatingService` for dynamic text substitution with fallback support
- **Widgets**: 
  - `ChatScreen` for displaying the interactive chat interface with choice buttons, text input, and automatic template processing
  - `UserVariablesPanel` for displaying stored user data in a sliding overlay panel
- **Assets**: JSON file containing branching chat script with choices, text input prompts, and storage keys

### Chat Message Structure
```json
{
  "id": 1,
  "text": "Hello, {user.name|Guest}! Welcome to the app!",
  "delay": 1000,
  "sender": "bot",
  "isChoice": false,
  "isTextInput": false,
  "storeKey": "user.name",
  "choices": [
    {"text": "Option 1", "nextMessageId": 10}
  ],
  "nextMessageId": 2
}
```
- `id`: Unique identifier for the message
- `text`: The message content to display (supports templating with `{key}` or `{key|fallback}` syntax)
- `delay`: Milliseconds to wait before showing this message
- `sender`: Either "bot" or "user" to determine message styling
- `isChoice`: Boolean indicating if this message presents choices to the user
- `isTextInput`: Boolean indicating if this message expects text input from user
- `storeKey`: Optional key to store user input or choice selection for future recall
- `choices`: Array of choice objects with text and next message ID
- `nextMessageId`: ID of the next message in the conversation flow

### Interactive Features
- **Choice Selection**: Users can tap buttons to select conversation paths
- **Text Input**: Users can type responses for personalization
- **Branching Conversations**: Different paths based on user choices
- **Message Flow Control**: Service manages conversation state and progression
- **User Response Handling**: Creates user messages and continues conversation flow
- **Data Persistence**: User inputs and choices are automatically stored locally
- **Text Templating**: Messages are personalized using stored user data
- **Fallback Values**: Professional messaging with `{key|fallback}` syntax prevents raw placeholders
- **User Variables Panel**: Sliding overlay accessible via person icon in AppBar showing all stored user data

### Getting Started
1. Ensure Flutter SDK is installed and configured
2. Run `flutter pub get` to install dependencies
3. Use `flutter test` to verify all tests pass (77/77 core tests should pass)
4. Use `flutter run` to start the interactive chat application
5. Explore the chat interface with choice-based navigation, text input, and personalization
6. Test the user information recall by entering your name and seeing personalized messages
7. Access the User Variables Panel by tapping the person icon in the AppBar to view stored data
8. Begin development by following TDD principles and updating relevant models, services, or widgets

### User Information Recall System
The app now includes a comprehensive system for storing and recalling user information:

#### **Data Storage**
```dart
// Store user data
await userDataService.storeValue('user.name', 'Alice');
await userDataService.storeValue('user.preferences', ['dark_theme', 'notifications']);

// Retrieve stored data
final name = await userDataService.getValue<String>('user.name');
final hasData = await userDataService.hasValue('user.name');
```

#### **Text Templating**
```json
{
  "text": "Welcome back, {user.name|valued user}! Your theme is {user.theme|default}.",
  "storeKey": "user.visit_count"
}
```

**Template Syntax:**
- `{key}` - Use stored value or leave unchanged if not found
- `{key|fallback}` - Use stored value or fallback if not found

#### **Automatic Data Collection**
- Text input messages with `storeKey` automatically store user responses
- Choice messages with `storeKey` automatically store selected options
- Data persists across app sessions using shared_preferences

#### **Benefits**
- **Personalized Experience**: Messages adapt based on stored user data
- **Professional UX**: Fallback values prevent raw template placeholders
- **Local Privacy**: All data stored locally on device
- **Backward Compatible**: Existing chat scripts work unchanged

### User Variables Panel Feature
The app now includes a comprehensive User Variables Panel feature:

#### **Panel Access**
- Accessible via person icon (👤) in the ChatScreen AppBar
- Smooth sliding animation (300ms duration with easeInOut curve)
- Semi-transparent overlay for better UX
- Tap outside panel to close

#### **Data Display**
- Shows all stored user variables in clean key-value format
- Handles different data types (strings, lists, booleans, numbers)
- Empty state message when no data exists
- Loading indicator during data fetch
- Automatic data refresh when panel opens

#### **Technical Implementation**
- `UserVariablesPanel` widget with Material Design styling
- Uses existing `UserDataService.getAllData()` method
- Integrated into `ChatScreen` with proper state management
- Follows TDD principles with comprehensive test coverage
- Cross-platform compatible (iOS, Android, Web, Desktop)

#### **Benefits**
- **Data Transparency**: Users can view all their stored information
- **Professional UX**: Smooth animations and consistent styling
- **Non-Intrusive**: Overlay design doesn't interrupt chat flow
- **Maintainable**: Clean architecture following existing app patterns
- **Extensible**: Ready for future enhancements (editing, export, etc.)

### Notes
- This is a private package (`publish_to: 'none'`)
- Uses Material Design by default
- Hot reload is supported for faster development
- All platforms are pre-configured and ready for development